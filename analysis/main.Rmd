---
title: "2019-11-auswirkungen-klimawandel"
author: "SRF Data, Felix Michel (felix.michel@srf.ch), Aline Metzler (aline.metzler@srf.ch)"
date: "November 2019"
output:
  html_document:
    code_folding: show
    echo: TRUE
    warning: FALSE
    message: FALSE
    theme: simplex
    df_print: kable
    toc: yes
    toc_depth: 4
    toc_float: 
      collapsed: false
      smooth_scroll: false
subtitle: Vorprozessierung und Analyse
---


```{r, echo=FALSE}
# CONFIG
user_name <- "srfdata" # github user name
project_name <- "2019-11-auswirkungen-klimawandel" # adapt to new repo name
package_date <- "2019-03-01" # date of the CRAN snapshot that
# the checkpoint package uses
R_version <- "3.5.3" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (R_version != paste0(version$major, ".", version$minor)){
  stop("ERROR: specified R version does not match currently used.")
}
```

## Vorbemerkungen

Dieses Dokument beschreibt die Vorprozessierung und explorative Analyse des Datensatzes, der Grundlage des auf srf.ch veröffentlichten Artikel [XYZ](https://www.srf.ch/data) ist.

SRF Data legt Wert darauf, dass die Datenvorprozessierung und -Analyse nachvollzogen und überprüft werden kann. SRF Data glaubt an das Prinzip offener Daten, aber auch offener und nachvollziehbarer Methoden. Zum anderen soll es Dritten ermöglicht werden, auf dieser Vorarbeit aufzubauen und damit weitere Auswertungen oder Applikationen zu generieren. 

Die Endprodukte des vorliegenden Scripts, neben der vorliegenden explorativen Analyse, sind JSON-Dateien zu den Klimaszenarien für jede Gemeinde und ein JSON-File mit allen Metainformationen zu den Gemeinden (Datenbeschreibung siehe unten):

* `output/climate_projections_bfsId.json`: Das Skript generiert 2212 Dateien, für jede Gemeinde eine Datei. Die Dateien tragen jeweils die Gemeindenummer des Bundesamts für Statistik (BfS) im Dateinamen. In den Dateien sind alle Klimavariablen enthalten, zwei simulierte Szenarien, alle drei Zeitperioden und alle drei Schätzungen.

* `output/municipalities.json`: Metainformationen zu allen Gemeinden, Gemeindestand 1. Januar 2019.

### R-Script & Daten

Die Vorprozessierung und Analyse wurde im Statistikprogramm R vorgenommen. Das zugrunde liegende Script sowie die prozessierten Daten können unter [diesem Link](https://srfdata.github.io/`r project_name`/rscript.zip) heruntergeladen werden. Durch Ausführen von `main.Rmd` kann der hier beschriebene Prozess nachvollzogen und der für den Artikel verwendete Datensatz generiert werden. Dabei werden Daten aus dem Ordner `input` eingelesen und Ergebnisse in den Ordner `output` geschrieben. 

SRF Data verwendet das [rddj-template](https://github.com/grssnbchr/rddj-template) von Timo Grossenbacher als Grundlage für seine R-Scripts.  Entstehen bei der Ausführung dieses Scripts Probleme, kann es helfen, die Anleitung von [rddj-template](https://github.com/grssnbchr/rddj-template) zu studieren. 

Debug-Informationen: *This report was generated on `r Sys.time()`. R version: `r paste0(version$major, ".", version$minor)` on `r version$platform`. For this report, CRAN packages as of `r package_date` were used.*

### GitHub

Der Code für die vorliegende Datenprozessierung ist auf [https://github.com/srfdata/`r project_name`](https://github.com/srfdata/`r project_name`) zur freien Verwendung verfügbar. 


### Lizenz

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Lizenzvertrag" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Dataset" property="dct:title" rel="dct:type">`r project_name`</span> von <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/srfdata/`r project_name`" property="cc:attributionName" rel="cc:attributionURL">SRF Data</a> ist lizenziert unter einer <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz</a>.

### Weitere Projekte

Code & Daten von [SRF Data](https://srf.ch/data) sind unter [https://srfdata.github.io](https://srfdata.github.io) verfügbar.

### Haftungsausschluss

Die veröffentlichten Informationen sind sorgfältig zusammengestellt, erheben aber keinen Anspruch auf Aktualität, Vollständigkeit oder Richtigkeit. Es wird keine Haftung übernommen für Schäden, die  durch die Verwendung dieses Scripts oder der daraus gezogenen Informationen entstehen. Dies gilt ebenfalls für Inhalte Dritter, die über dieses Angebot zugänglich sind.

### Datenbeschreibung

#### `output/climate_projections_bfsId.json`

Für jede, der 2212 Gemeinden wird eine JSON-Datei generiert mit allen nötigen Klimavariablen, Szenarien, Perioden und Schätzungen.

| Attribut | Typ | Beschreibung |
|-------|------|-----------------------------------------------------------------------------|
| bfs_id | Number | Gemeindenummer |
| key | String | Klimavariable (FD, snowdays, ID, SD, HD, TN, tas und pr) |
| period | String  | Zeitpunkt, den die Simulation abbiulden soll (1981-2010, 2035, 2060, 2085) |
| estimate | String | Schätzwerte für die Berechnungen, q5, q50 und q95 |
| rcp | String | Unterschiedliche Klimaszenarios (obs, RCP2.6, RCP8.5) |
| season | String | Wert für die Jahreszeit, nur vorhanden bei den Variablen pr und tas |


#### `output/municipality.json`

| Attribut | Typ | Beschreibung |
|-------|------|-----------------------------------------------------------------------------|
| bfs_id | Number | Gemeindenummer |
| name | String | Gemeindename |
| altitude | String  | Höhenlage der Gemeinde |
| region | String | Grossregion der Gemeinde |
| urban | Boolean | Grosstadt oder Agglomeration |


### Originalquelle

[Die Daten des interaktiven Artikel stammen hauptsächlich von den «Klimaszenarien CH2018»](https://www.nccs.admin.ch/nccs/de/home/materialien-und-daten/daten/ch2018---klimaszenarien-fuer-die-schweiz.html), die im November 2018 veröffentlicht wurden (CH2018 Project Team (2018): CH2018 - Climate Scenarios for Switzerland. 
National Centre for Climate Services. doi: 
10.18751/Climate/Scenarios/CH2018/1.0). Die «Klimaszenarien CH2018» sind Simulationen mit insgesamt 21 verschiedenen Computermodellen, die am EURO-CORDEX («Coordinated Regional Climate Downscaling Experiment – European Domain») betrieben werden. Das Projekt wird vom Weltklimaforschungsprogramm (WRCP) gesponsert.
Die regionalen Klimasimulationen berücksichtigen drei verschiedene Szenarien, je nach Entwicklung der Treibhausgasemissionen:

Die regionalen Klimasimulationen berücksichtigen drei verschiedene Szenarien, je nach Entwicklung der Treibhausgasemissionen:

* Kein Klimaschutz (RCP8.5): Die klimawirksamen Emissionen nehmen stetig zu (hier verwendet als «pessimistisches Szenario»)

* Konsequenter Klimaschutz (RCP2.6): Der Anstieg der Treibhausgase in der Atmosphäre kann bis in 20 Jahren gestoppt werden (hier verwendet als «optimistisches Szenario»)

* Begrenzter Klimaschutz (RCP4.5): Eine mittlere Entwicklung mit begrenztem Klimaschutz (hier nicht verwendet)

Die Klimaszenarien CH2018 beziehen sich jeweils auf einen Mittelwert der geschätzten klimatischen Verhältnisse über einen längeren Zeitraum. Wenn es im Text «2035» heisst, bezieht sich das auf die nahe Zukunft von 2020-2049. Ist die Rede von «2060», geht es um die Mitte des Jahrhunderts (2045-2074) und «2085» bezieht sich auf das Ende des Jahrhunderts (2070-2099). Als Referenzperiode gilt der Zeitraum von 1981 bis 2010. Werte von «heute» sind also gemittelte Messwerte über diesen Zeitraum.

Diese Projektionen der Klimamodelle sind jedoch nicht exakt, sondern streuen immer über einen gewissen Bereich. Der Median davon entspricht am ehesten dem absehbaren Wert und wird als «erwartetes» Ergebnis behandelt.

##### Gitternetz-Daten der Klimaszenarien 2018
Die Daten wurden im Dateiformat [netCDF](https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_introduction.html) geliefert. Für jede Klimavariable gibt es einen Ordner.

&rarr; `input/FD_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Frosttagen.

&rarr; `input/HD_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Hitzetagen

&rarr; `input/ID_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Eistagen.

&rarr; `input/SD_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Sommertagen.

&rarr; `input/snowdays_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Schneetagen.

&rarr; `input/TN_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Tropennächten.

&rarr; `input/tas_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Tagesmittelwerten für die Temperatur nach Jahreszeit.

&rarr; `input/pr_obs_CH2018`

In diesem Ordner befinden sich die Dateien zu den Tagesmittelwerten für Niederschlag nach Jahreszeit.


#### Klimatische Regionen
&rarr; `input/climate_regions`

In diesem Ordner befinden sich die Dateien aufgeteilt und gemittelet nach Region. In jeder Datei sind alle Klimavariablen, Szenarien etc. vorhanden. Das Dateiformat ist ebenfalls netCDF. Die Daten stammen von [MeteoSchweiz](https://www.meteoschweiz.admin.ch/home.html?tab=overview).

#### Gemeindegrenzen
&rarr; `input/gd-b-00.03-875-gg17`

Die Shapedateien für die Gemeinden und Kantonen können hier runtergeladen werden: [Generalisierte Gemeindegrenzen](https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.assetdetail.1902553.html).

#### Grossregionen

&rarr; `input/Grossregionen`
Die Shapedatei zu den Grossregionen bildet die regionale Einteiung ab, die MeteoSchweiz für die Bewertung der Risiken und Chancen verwendet hat. Die Daten stammen von [MeteoSchweiz](https://www.meteoschweiz.admin.ch/home.html?tab=overview).


## Vorbereitungen

```{r, echo=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <-  c("stats",
                             "graphics",
                             "grDevices",
                             "utils",
                             "datasets",
                             "methods",
                             "base")
  basic_packages <- paste("package:", basic_packages_blank, sep = "")

  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)]

  package_list <- setdiff(package_list, basic_packages)

  if (length(package_list) > 0)  for (package in package_list) {
    detach(package, character.only = TRUE, unload = TRUE)
    print(paste("package ", package, " detached", sep = ""))
  }
}

detach_all_packages()

# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if ( is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  print("WARNING: No working directory specified for current user")
} else {
  setwd(path_to_wd)
}

# suppress scientific notation
options(scipen = 999)

# unload global rstudioapi and knitr again to avoid conflicts with checkpoint
# this is only necessary if executed within RStudio
# outside of RStudio, namely in the knit.sh script, this causes RMarkdown
# rendering to fail, thus should not be executed there
if (Sys.getenv("RSTUDIO") == "1"){
  detach_all_packages()
}
```


### Packages definieren

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# from https://mran.revolutionanalytics.com/web/packages/checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting is probably not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(rstudioapi)
library(rgdal)
library(raster) # raster used for relief important: load before tidyverse
library(glue) # cooler string templating
library(tidyverse) # ggplot2, dplyr, tidyr, readr, purrr, tibble
library(magrittr) # pipes
library(readxl) # excel
library(scales) # scales for ggplot2
library(jsonlite) # json
library(lintr) # code linting
library(sf) # spatial data handling
library(ncdf4) # package to read netCDF files
library(ncdf4.helpers)
library(PCICt)
library(rmarkdown)",
file = "manifest.R")
```

### Packages installieren

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github("RevolutionAnalytics/checkpoint",
                           ref = "v0.3.2", # could be adapted later,
                           # as of now (beginning of July 2017
                           # this is the current release on CRAN)
                           repos = "http://cran.us.r-project.org")
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshotDate = package_date,
           project = path_to_wd,
           verbose = T,
           scanForPackages = T,
           use.knitr = F,
           R.version = R_version)
rm(package_date)
```


### Packages laden

```{r, echo=TRUE, message=FALSE, warning=FALSE}
source("manifest.R")
unlink("manifest.R")
sessionInfo()
```

### Zusätzliche Scripts laden

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if you want to outsource logic to other script files, see README for 
# further information
knitr::read_chunk("scripts/my_script.R")
source("scripts/my_script.R")
my_function(5)
```

## Geographische Daten einlesen
Generalisierte Gemeindegrenzen und Grossregionen

```{r read geo data}

# read municipal borders
municipality_geo <- read_sf(
  "input/gd-b-00.03-875-gg19/ggg_2019-LV95/shp/g2g19.shp",
  # set crs to lv95
  crs = 2056
)

# create new sf object with city centers
municipality_geo_point <- municipality_geo %>%
  st_drop_geometry() %>%
  st_as_sf(coords = c("E_CNTR", "N_CNTR"),  crs = 2056)

# shapefiles including urban areas
big_regions_shapefile <- read_sf(
  "input/Grossregionen/Grossraeume_neu.shp",
  crs = 21781
) %>%
  # transform from old ch1903 to new lv95
  st_transform(2056)

```

## Daten zu den Klimaszenarien einlesen
In diesem Block werden die berechneten Klimaszenarien der Schweiz eingelesen.

### Klimaregionen einlesen
Wir lesen die Daten zu den Klimaregionen ein und matchen diese dann ebenfalls mit den Gemeinden. Dadurch können wir die Gemeinden einer Klimaregion zuordnen.

```{r read climate regions}

climate_regions_geo_points <- c(
  "Alpen", 
  "AlpenS", 
  "Jura", 
  "Voralpen", 
  "Mittelland"
  ) %>%
  map_df(function(region) {
    # determine filepath
    filepath <- glue("input/climate_regions/{region}.nc")
    if (file.exists(filepath)) {
      # extract all values of the selected climate variable
      current_file <- nc_open(filepath)
      lon <- ncvar_get(current_file, varid = "lon")
      lat <- ncvar_get(current_file, varid = "lat")
      current_region <- ncvar_get(current_file, region)
      current_region_vec <- as.vector(current_region)
      lonlat <- as.matrix(expand.grid(lon, lat))
      lonlat_df <- data.frame(
        cbind(
          lonlat, 
          current_region_vec
          )
        ) %>%
        filter(
          current_region_vec > 0
          ) %>% 
          mutate(current_region_vec = case_when(
      current_region_vec == 1 ~ region
      ))
      nc_close(current_file)
      result <- tibble(
        region = lonlat_df$current_region,
        lon = lonlat_df$Var1,
        lat = lonlat_df$Var2
        )
    }
    return(result)
  }
  ) %>%
  st_as_sf(coords = c("lon", "lat"),  crs = 4326) %>%
  st_transform(2056)

# join the two datasets (matched and missing muncipalities)
climate_regions_all_municipalities <- st_join(
  municipality_geo_point %>% 
    select(GMDNR, GMDNAME, geometry),
  climate_regions_geo_points,
  join = st_nearest_feature
  ) %>% 
  st_drop_geometry() %>% 
  select(GMDNR, region)

```


### Klimavariablen als Gitternetzpunkte einlesen

Wir lesen die Daten ein, machen einen Spatial-Join mit dem 2-km-Gitternetzpunkt, der einem Gemeindeortszentrum, am nächsten liegt.

```{r create data frame of netcdf climate files, eval=FALSE}

lonlat_filename <- "input/FD_obs_CH2018/FD_RCP2.6_2035_q5.nc"
lonlat_file <- nc_open(lonlat_filename)
lon <- ncvar_get(lonlat_file, varid = "lon")
lat <- ncvar_get(lonlat_file, varid = "lat")
lonlat <- as.matrix(expand.grid(lon, lat))

# cleanup
rm(lonlat_filename, lonlat_file, lon, lat)

climate_projections_wide <- c(
  "FD", "HD", "ID", "SD", "snowdays", "TN", "pr", "tas"
  ) %>%
  map_dfc(function(climate_variable) {
    # map through different rcp scenarios
      c("RCP2.6", "RCP4.5", "RCP8.5") %>%
      map_dfc(function(rcp) {
        # map through different periods
         c("2035", "2060", "2085") %>%
          map_dfc(function(period) {
            # map through different estimates
            c("q5", "q50", "q95") %>%
              map_dfc(function(estimate) {
                 # determine folder
                folder <- glue("{climate_variable}_obs_CH2018/")
                if (climate_variable == "pr" || climate_variable == "tas") {
                  # map through different seasons
                  c("DJF", "MAM", "JJA", "SON") %>% 
                    map_dfc(function(season) {
                      # determine filename
                      filename <- glue(
                        "{climate_variable}_",
                        "{rcp}_",
                        "{period}_",
                        "{season}_",
                        "{estimate}.nc"
                        )
                      filepath <- glue("input/{folder}{filename}")
                      if (file.exists(filepath)) {
                        current_file <- nc_open(filepath)
                        # extract all values of the selected climate variable
                        current_climate_values <- ncvar_get(
                          current_file, 
                          climate_variable
                          )
                        current_climate_values_vec <- as.vector(
                          current_climate_values
                          )
                        nc_close(current_file)
                        col_name <- glue(
                          "{climate_variable}|",
                          "{rcp}|",
                          "{period}|",
                          "{estimate}|",
                          "{season}"
                          )
                        result <- tibble(
                          !!col_name := current_climate_values_vec
                          )
                       }
                    })
                  }
                  else {
                   # determine filename
                   filename <- glue(
                     "{climate_variable}_{rcp}_{period}_{estimate}.nc"
                     )
                   filepath <- glue("input/{folder}{filename}")
                   if (file.exists(filepath)) {
                       current_file <- nc_open(filepath)
                       # extract all values of the selected climate variable
                       current_climate_values <- ncvar_get(
                         current_file,
                         climate_variable
                         )
                       current_climate_values_vec <- as.vector(
                         current_climate_values)
                       nc_close(current_file)
                       col_name <- glue(
                         "{climate_variable}|{rcp}|{period}|{estimate}"
                         )
                       result <- tibble(
                         !!col_name := current_climate_values_vec
                       )
                   }
                  }
                   })
              })
          })
      }
    ) %>% 
  cbind(lonlat) %>%
  rename(
    lon = Var1,
    lat = Var2
    )

# for some weird reason we can't read the observational data in the same map
climate_observations_wide <- c(
  "FD", "HD", "ID", "SD", "snowdays", "TN", "pr", "tas"
  ) %>%
  map_dfc(function(climate_variable) {
    # map through different rcp scenarios
      c("obs") %>%
      map_dfc(function(rcp) {
        # map through different periods
         c("1981-2010") %>%
          map_dfc(function(period) {
            # map through different estimates
            c("mean", "yearly_mean") %>%
              map_dfc(function(estimate) {
                 # determine folder
                folder <- glue("{climate_variable}_obs_CH2018/")
                if (climate_variable == "pr" || climate_variable == "tas") {
                  # map through different seasons
                  c("DJF", "MAM", "JJA", "SON") %>% 
                    map_dfc(function(season) {
                      # determine filename
                      filename <- glue(
                        "{climate_variable}_",
                        "{rcp}_",
                        "{period}_",
                        "{season}_",
                        "{estimate}.nc"
                        )
                      filepath <- glue("input/{folder}{filename}")
                      if (file.exists(filepath)) {
                        current_file <- nc_open(filepath)
                        # extract all values of the selected climate variable
                        current_climate_values <- ncvar_get(
                          current_file, 
                          climate_variable
                          )
                        current_climate_values_vec <- as.vector(
                          current_climate_values
                          )
                        nc_close(current_file)
                        col_name <- glue(
                          "{climate_variable}|",
                          "{rcp}|",
                          "{period}|",
                          "{estimate}|",
                          "{season}"
                          )
                        result <- tibble(
                          !!col_name := current_climate_values_vec
                          )
                       }
                    })
                  }
                  else {
                   # determine filename
                   filename <- glue(
                     "{climate_variable}_{rcp}_{period}_{estimate}.nc"
                     )
                   filepath <- glue("input/{folder}{filename}")
                   if (file.exists(filepath)) {
                       current_file <- nc_open(filepath)
                       # extract all values of the selected climate variable
                       current_climate_values <- ncvar_get(
                         current_file, 
                         climate_variable
                         )
                       current_climate_values_vec <- as.vector(
                         current_climate_values
                         )
                       nc_close(current_file)
                       col_name <- glue(
                         "{climate_variable}|{rcp}|{period}|{estimate}"
                         )
                       result <- tibble(
                         !!col_name := current_climate_values_vec
                       )
                   }
                  }
                   })
              })
          })
      }
    ) %>% 
  cbind(lonlat) %>% 
  rename(
    lon = Var1, 
    lat = Var2
    )

# put the two data sets together (observations and projections)
climate_data_all_grid_points <- climate_projections_wide %>% 
  left_join(climate_observations_wide,
            by = c("lon" = "lon", "lat" = "lat")) %>% 
  group_by(lat, lon) %>% 
  drop_na()

# create geo point of lat lon from netcdf files
climate_values_geo_point <- climate_data_all_grid_points %>%
  st_as_sf(coords = c("lon", "lat"),  crs = 4326) %>%
  st_transform(2056)

# look for grid point that is closest (st_nearest feature) to the municipality
climate_values_all_municipalities <- st_join(
  municipality_geo_point %>% select(GMDNR, GMDNAME, geometry),
  climate_values_geo_point,
  join = st_nearest_feature
  ) %>% 
  st_drop_geometry() %>% 
  select(GMDNR, GMDNAME, everything())

# convert wide data frame into long data frame
climate_projections_by_municipality <- 
  climate_values_all_municipalities %>% 
  gather(string, value, -GMDNR, -GMDNAME) %>%
  # extract keys of climate variables
  tidyr::extract(
    col = "string",
    into = c("key", "rcp", "period", "estimate", "season"),
    regex = "(\\w+)\\|([\\w\\.]+)\\|([\\d-]+)\\|(\\w+)(?:\\|(\\w+))?",
    remove = TRUE
  ) %>%
  rename(bfs_id = GMDNR)

# join altitude information and climate regions
climate_projections_by_municipality %<>%
  left_join(
    municipality_geo %>% 
      st_drop_geometry() %>% 
      select(GMDNR, Z_CNTR), 
    by = c("bfs_id" = "GMDNR")
  ) %>% 
  mutate(
    altitude = case_when(
      Z_CNTR <= 800 ~ "0-800",
      Z_CNTR > 800 & Z_CNTR <= 1500 ~ "801-1500",
      Z_CNTR > 1500 ~ ">1500"
    )
  ) %>%
  select(-Z_CNTR) %>%
  # join climate regions from chunk above
  left_join(
    climate_regions_all_municipalities,
    by = c("bfs_id" = "GMDNR")
  )

#cleanup
rm(
  lonlat, 
  climate_projections_wide,
  climate_observations_wide,
  climate_data_all_grid_points, 
  climate_values_by_municipality,
  municipalities_with_no_match,
  climate_values_municipalities_no_match,
  climate_values_all_municipalities
  )

# save the data frame to an Rdata file
save(
  climate_projections_by_municipality, 
  file = "climate_projections_by_municipality.Rdata"
  )
save(
  climate_values_geo_point, 
  file = "climate_values_geo_point.Rdata"
  )

```



```{r load climate data from Rdata}

if (file.exists("climate_projections_by_municipality.Rdata")) {
  print("loading climate data")
  load("climate_projections_by_municipality.Rdata")
} else {
  print("please run the big chunk above")
}

```


## Analyse
Zuerst werden unterschiedliche Funktionen erstellt, um dann in den Unterkapitel zu den einzelnen Variablen jeweils die Funktionen aufrufen zu können.

```{r prepare functions}

# function to translate keys to word describing the climate variable
translate_key_to_word <- function(key_id) {
  case_when(
    key_id == "FD" ~ "Frosttage",
    key_id == "HD" ~ "Hitzetage",
    key_id == "ID" ~ "Eistage",
    key_id == "SD" ~ "Sommertage",
    key_id == "snowdays" ~ "Schneetage",
    key_id == "TN" ~ "Tropennächte",
    key_id == "tas" ~ "Temperatur",
    key_id == "pr" ~ "Niederschlagsmenge"
  )
}

# display all municipalities in a hisogram
HistogramPlot <- function(data, key_id, period_val, rcp_val){
  colors <- c("#1cb0b5", "#e31f2b")
  names(colors) <- c("1981-2010", period_val)
  data %>%
    filter(key == key_id &
           period %in% c("1981-2010", period_val) &
           rcp %in% c("obs", rcp_val) &
           estimate %in% c("yearly_mean", "q50")) %>%
    group_by(period) %>%
    ggplot(aes(value, fill = period)) +
    geom_histogram(alpha = 0.4, position = "identity") +
    scale_fill_manual(values = colors) +
    theme_minimal() +
    labs(title = glue(
      "Wie hat sich die Anzahl 
      {translate_key_to_word(key_id)} im Vergleich 
      zum Mittelwert von 1981-2010 verändert?"
      ),
      subtitle = glue("Prognose für {rcp_val}"),
      x = glue(
          "Durchschnittliche Anzahl 
          {translate_key_to_word(key_id)} pro Jahr"
          ),
      y = "Anzahl Gemeinden",
      fill = "")
  }

# display all municipalities in a violin plot
ViolinPlot <- function(data, key_id, var, grouping_var){
  data %>%
    filter(key == key_id &
           (rcp == var | period == var) &
           estimate == "q50") %>%
    group_by(!!sym(grouping_var)) %>%
    ggplot(aes(x = !!sym(grouping_var), y = value)) +
    geom_violin() +
    theme_minimal() +
    labs(title = glue("Szenarien für {translate_key_to_word(key_id)}"),
        subtitle = ifelse(
          var %in% c("RCP2.6", "RCP4.5", "RCP8.5"), 
          glue("Prognose des {var}"), 
          glue("Klimaszenarien im Jahr {var}")
          ),
        x = "",
        y = glue(
          "Durchschnittliche Anzahl 
          {translate_key_to_word(key_id)} pro Jahr"
          ),
        fill = "")
  }
 
# find outlier municipalities
ExtremeMunicipalities <- function(data, key_id, period_val, rcp_val){
  data %>%
    filter(key == key_id &
           period %in% c("1981-2010", period_val) &
           rcp %in% c("obs", rcp_val) &
           estimate %in% c("yearly_mean", "q50")) %>%
    select(-rcp, -estimate, -season) %>%
    mutate(period = case_when(
      period == "1981-2010" ~ "now",
      period == period_val ~ "future"
    )) %>% 
    spread(key = period, value = value) %>% 
    mutate(
      delta = future - now
    ) %>%
    arrange(delta) %>%
    ungroup() %>%
    # Get first and last 10
    slice(1:10, (n() - 9):n())
}

# mean per season Plot
Seasons <- function(data, key_id, period_val, rcp_val){
  colors <- c("#1cb0b5", "#e31f2b")
  names(colors) <- c("1981-2010", period_val)
  
  data %>%
    filter(key == key_id &
           period %in% c("1981-2010", period_val) &
           rcp %in% c("obs", rcp_val) &
           estimate %in% c("mean", "q50")) %>%
    mutate(season = case_when(
        season == "MAM" ~ "Mär, Apr, Mai",
        season == "JJA" ~ "Jun, Jul, Aug",
        season == "SON" ~ "Sep, Okt, Nov",
        season == "DJF" ~ "Dez, Jan, Feb"
    ),
    season = factor(season, levels = c(
        "Mär, Apr, Mai",
        "Jun, Jul, Aug",
        "Sep, Okt, Nov",
        "Dez, Jan, Feb"))
    ) %>%
    group_by(period, season) %>%
    ggplot(aes(value, fill = period)) +
    geom_histogram(alpha = 0.4, position = "identity") +
    scale_fill_manual(values = colors) +
    theme_minimal() +
    facet_wrap(~ season, nrow = 1) +
    labs(title = glue(
      "Wie hat sich der saisonale Tagesmittelwerte der 
      {translate_key_to_word(key_id)} im
      Vergleich zum Mittelwert von 1981-2010 verändert?"
      ),
      subtitle = glue("Prognose des {rcp_val}"),
      x = glue("Tagesmittelwert 
               {translate_key_to_word(key_id)} 
               pro Jahreszeit"),
      y = "Anzahl Gemeinden",
      fill = "")
  }

# Plot which regions are sensitive to possible outcomes
Regions <- function(data, key_id, rcp_val){
  data %>%
    filter(key == key_id &
            rcp %in% c("obs", rcp_val) &
            estimate %in% c("yearly_mean", "q50")
            ) %>%
    ungroup() %>%
    mutate(
      region = factor(region, levels = c(
        "Jura",
        "Mittelland",
        "Voralpen",
        "Alpen",
        "AlpenS"
      )),
      altitude = factor(altitude, levels = c(
        "0-800",
        "801-1500",
        ">1500"))
        ) %>%
    group_by(period, region, altitude, rcp) %>%
    summarise(mean = mean(value)) %>%
    ggplot(aes(x = period,
               y = mean,
               fill = period)) +
    geom_bar(stat = "identity", 
               position = position_dodge2(reverse = TRUE)) +
    facet_grid(cols = vars(region), 
               rows = vars(altitude)) +
    scale_x_discrete(labels = NULL) +
    scale_fill_manual(values = c(
      "1981-2010" = "#ffd651",
      "2035" = "#f7a600",
      "2060" = "#ed7004",
      "2085" = "#ad3e14"
      )) +
    theme_minimal() +
    labs(title = glue(
      "Wie hat sich die durchschittliche Anzahl 
      {translate_key_to_word(key_id)} im
      Vergleich zum Mittelwert von 1981-2010 verändert?"
      ),
      subtitle = glue("Prognose des {rcp_val} nach Grossregion"),
      x = "",
      y = glue("Durchschnittliche Anzahl {translate_key_to_word(key_id)}"),
      fill = "")
  }

# Region and Season
translate_season <- function(season_val){
  case_when(
    season_val == "MAM" ~ "März, April, Mai",
    season_val == "JJA" ~ "Juni, Juli, August",
    season_val == "SON" ~ "September, Oktober, November",
    season_val == "DJF" ~ "Dezember, Januar, Februar")
}

RegionsSeason <- function(data, key_id, rcp_val, season_val){
  data %>%
    filter(key == key_id &
            rcp %in% c("obs", rcp_val) &
            estimate %in% c("mean", "q50") &
            season == season_val
            ) %>%
    ungroup() %>%
    mutate(
      region = factor(region, levels = c(
        "Jura",
        "Mittelland",
        "Voralpen",
        "Alpen",
        "AlpenS"
      )),
      altitude = factor(altitude, levels = c(
        "0-800",
        "801-1500",
        ">1500"))
        ) %>%
    group_by(period, region, altitude, rcp) %>%
    summarise(mean = mean(value)) %>%
    ggplot(aes(x = period,
               y = mean,
               fill = period)) +
    geom_bar(stat = "identity", 
               position = position_dodge2(reverse = TRUE)) +
    facet_grid(cols = vars(region), 
               rows = vars(altitude)) +
    scale_x_discrete(labels = NULL) +
    scale_fill_manual(values = c(
      "1981-2010" = "#ffd651",
      "2035" = "#f7a600",
      "2060" = "#ed7004",
      "2085" = "#ad3e14"
      )) +
    theme_minimal() +
    labs(title = glue(
      "Wie hat sich der Mittelwert der 
      {translate_key_to_word(key_id)} im Vergleich zum 
      Mittelwert von 1981-2010 verändert ({translate_season(season_val)})?"),
      subtitle = glue("Prognose des {rcp_val} nach Grossregion"),
      x = "",
      y = glue("Durchschnittliche Anzahl {translate_key_to_word(key_id)}"),
      fill = "")
  }

LineChartPerMunicipality <- function(data, municipality, key_id) {
  data %>%
    filter(
      GMDNAME == municipality,
      key == key_id,
      estimate %in% c("yearly_mean", "q50")) %>%
    ggplot(aes(x = period, y = value, group = rcp, color = rcp)) +
    geom_line() +
    geom_point() +
    theme_minimal() +
    labs(title = glue(
      "Wie hat sich der Mittelwert der 
      {translate_key_to_word(key_id)} im Vergleich zum 
      Mittelwert von 1981-2010 verändert?"
      ),
      subtitle = glue("Prognose für {municipality}"),
      x = "",
      y = glue("Durchschnittliche Anzahl {translate_key_to_word(key_id)}"),
      fill = "")
  }

# Small Multiple Maps
SmallMultipleMaps <- function(data, key_id, rcp_val, estimate_val) {
  municipality_geo %>%
  left_join(
    data %>%
      filter(
        key == key_id,
        rcp == rcp_val,
        estimate %in% c("yearly_mean", estimate_val)
      ),
    by = c("GMDNR" = "bfs_id")
  ) %>%
  ggplot(aes(
    fill = value
  )) +
    geom_sf(color = "transparent") +
    facet_wrap(~ period, ncol = 2) +
    theme(
      axis.line = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.background = element_blank(),
      panel.border = element_blank()
      ) +
    labs(
      title = glue(
        "{translate_key_to_word(key_id)}, {rcp_val}, {estimate_val}"
        ),
      fill = translate_key_to_word(key_id)
      ) +
    scale_fill_viridis_c()
  }

```


```{r line plots by municipality}

LineChartPerMunicipality(climate_projections_by_municipality, "Zürich", "FD")

LineChartPerMunicipality(climate_projections_by_municipality, "Zürich", "HD")

LineChartPerMunicipality(climate_projections_by_municipality, "Zürich", "TN")

LineChartPerMunicipality(climate_projections_by_municipality, "Zürich", "ID")

LineChartPerMunicipality(climate_projections_by_municipality, "Zürich", "SD")

LineChartPerMunicipality(
  climate_projections_by_municipality, 
  "Zürich", "snowdays"
  )


```

#### Frosttage (FD)

Am stärksten zeigt sich der Rückgang der Frosttage in den Alpen. In gewissen Berggemeinden gibt es gemäss Prognose (RCP2.6) bereits im Jahr 2035 mehr als 20 Frosttage weniger.

```{r frostdays plots}
## Histogram
# 2035 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "FD", "2035", "RCP4.5")

# 2060 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "FD", "2060", "RCP4.5")

# 2085 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "FD", "2085", "RCP4.5")

## Violin Plot
# Year 2085, prognosis with different RCP
ViolinPlot(climate_projections_by_municipality, "FD", "2085", "rcp") 
# Prognosis with RCP8.5 for different periods
ViolinPlot(climate_projections_by_municipality, "FD", "RCP8.5", "period")

# Maps for RCP8.5 all periods
SmallMultipleMaps(climate_projections_by_municipality, "FD", "RCP8.5", "q50")

# Extreme municipalities for certain scenario
ExtremeMunicipalities(
  climate_projections_by_municipality, 
  "FD", "2035", "RCP2.6"
  )

# Different regions compared
Regions(climate_projections_by_municipality, "FD", "RCP4.5")

```

#### Hitzetage (HD)

Bei den Hitzetagen kommt es in den Grossen Agglomerationen, im Mittelland und im Jura zu krassen Veränderungen. In allen drei Gebieten verdoppelt sich gemäss Prognose (RCP4.5) die Anzahl der Hitzetage bis 2080.

```{r heatdays plots}
## Histogram
# 2035 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "HD", "2035", "RCP4.5")

# 2060 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "HD", "2060", "RCP4.5")

# 2085 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "HD", "2085", "RCP4.5")

## Violin Plot
# Year 2085, prognosis with different RCP
ViolinPlot(climate_projections_by_municipality, "HD", "2085", "rcp") 
# Prognosis with RCP8.5 for different periods
ViolinPlot(climate_projections_by_municipality, "HD", "RCP8.5", "period")

# Maps for RCP8.5 all periods
SmallMultipleMaps(climate_projections_by_municipality, "HD", "RCP8.5", "q50")

# Extreme municipalities for certain scenario
ExtremeMunicipalities(
  climate_projections_by_municipality, 
  "HD", "2035", "RCP2.6"
  )

# Different regions compared
Regions(climate_projections_by_municipality, "HD", "RCP4.5")
```

#### Eistage (ID)

Bei Gemeinden in den Alpen ist der Rückgang der Eistage am stärksten ausgeprägt. Gewisse Berggemeinden haben gemäss Prognose (RCP2.6) bereits im Jahr 2035 beinahe 20 Eistage weniger.


```{r icedays plots}
## Histogram
# 2035 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "ID", "2035", "RCP4.5")

# 2060 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "ID", "2060", "RCP4.5")

# 2085 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "ID", "2085", "RCP4.5")

## Violin Plot
# Year 2085, prognosis with different RCP
ViolinPlot(climate_projections_by_municipality, "ID", "2085", "rcp") 
# Prognosis with RCP8.5 for different periods
ViolinPlot(climate_projections_by_municipality, "ID", "RCP8.5", "period")

# Maps for RCP8.5 all periods
SmallMultipleMaps(climate_projections_by_municipality, "ID", "RCP8.5", "q50")

# Extreme municipalities for certain scenario
ExtremeMunicipalities(
  climate_projections_by_municipality, 
  "ID", "2035", "RCP2.6"
  )

# Different regions compared
Regions(climate_projections_by_municipality, "ID", "RCP4.5")

```

#### Sommertage (SD)

Die Sommertage nehmen deutlich zu. Dies zeigt sich vor allem im Jura, in den grossen Agglomerationen und im Mittelland.

```{r summerdays plots}
## Histogram
# 2035 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "SD", "2035", "RCP4.5")

# 2060 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "SD", "2060", "RCP4.5")

# 2085 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "SD", "2085", "RCP4.5")

## Violin Plot
# Year 2085, prognosis with different RCP
ViolinPlot(climate_projections_by_municipality, "SD", "2085", "rcp") 
# Prognosis with RCP8.5 for different periods
ViolinPlot(climate_projections_by_municipality, "SD", "RCP8.5", "period")

# Maps for RCP8.5 all periods
SmallMultipleMaps(climate_projections_by_municipality, "SD", "RCP8.5", "q50")

# Extreme municipalities for certain scenario
ExtremeMunicipalities(
  climate_projections_by_municipality, 
  "SD", "2035", "RCP2.6"
  )

# Different regions compared
Regions(climate_projections_by_municipality, "SD", "RCP4.5")
```

#### Schneetage (snowdays)

Der Rückgang der Schneetage betrifft die Berggebiete am stärksten. In gewissen Berggemeinden wird es laut Prognose mehr als 15 Schneetage weniger geben.

```{r snowdays plots}
## Histogram
# 2035 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "snowdays", "2035", "RCP4.5")

# 2060 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "snowdays", "2060", "RCP4.5")

# 2085 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "snowdays", "2085", "RCP4.5")

## Violin Plot
# Year 2085, prognosis with different RCP
ViolinPlot(climate_projections_by_municipality, "snowdays", "2085", "rcp") 
# Prognosis with RCP8.5 for different periods
ViolinPlot(climate_projections_by_municipality, "snowdays", "RCP8.5", "period")

# Maps for RCP8.5 all periods
SmallMultipleMaps(
  climate_projections_by_municipality, 
  "snowdays", "RCP8.5", "q50"
  )

# Extreme municipalities for certain scenario
ExtremeMunicipalities(
  climate_projections_by_municipality, 
  "snowdays", "2035", "RCP2.6"
  )

# Different regions compared
Regions(climate_projections_by_municipality, "snowdays", "RCP4.5")
```

#### Tropennächte (TN)

Aktuell sind Tropennächte in der Schweiz eine Besonderheit. In den meisten Gemeinden gab es im langjährigen Mittel (1981-2010) keine Tropennächte. In der Zukunft ändert sich das. Vor allem in den grossen Agglomerationen kann es gemäss Prognose (RCP4.5) bis 2080 durchschnittlich 5 Tropennächte geben.

```{r tropical nights}
## Histogram
# 2035 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "TN", "2035", "RCP4.5")

# 2060 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "TN", "2060", "RCP4.5")

# 2085 mit RCP4.5
HistogramPlot(climate_projections_by_municipality, "TN", "2085", "RCP4.5")

## Violin Plot
# Year 2085, prognosis with different RCP
ViolinPlot(climate_projections_by_municipality, "TN", "2085", "rcp") 
# Prognosis with RCP8.5 for different periods
ViolinPlot(climate_projections_by_municipality, "TN", "RCP8.5", "period")

# Maps for RCP8.5 all periods
SmallMultipleMaps(climate_projections_by_municipality, "TN", "RCP8.5", "q50")

# Extreme municipalities for certain scenario
ExtremeMunicipalities(
  climate_projections_by_municipality, 
  "TN", "2035", "RCP2.6"
  )

# Different regions compared
Regions(climate_projections_by_municipality, "TN", "RCP4.5")

```

#### Tagesmittelwerte (Temperatur)

Bei allen drei Szenarien wird die Temperatur in allen vier Jahreszeiten steigen. Im Schnitt um etwa 1.2 Grad Celsius (1981-2010 vs. 2085) mit RCP2.6 oder 4 Grad Celsius mit RCP8.5. 

```{r temperature}
Seasons(climate_projections_by_municipality, "tas", "2085", "RCP8.5")

## Regions and altitude
# spring
RegionsSeason(climate_projections_by_municipality, "tas", "RCP4.5", "MAM")
# summer
RegionsSeason(climate_projections_by_municipality, "tas", "RCP4.5", "JJA")
# autumn
RegionsSeason(climate_projections_by_municipality, "tas", "RCP4.5", "SON")
# winter
RegionsSeason(climate_projections_by_municipality, "tas", "RCP4.5", "DJF")
```

#### Tagesmittelwerte (Niederschlag)

Die Veränderung der Niederschlagsmenge ist sehr unterschiedlich je nach Jahreszeit. Im Schnitt wird sie in den Frühlings- und Wintermonaten eher grösser, in den Herbstmonaten in etwa gleich bleiben und in den Sommermonaten kleiner. Diese Tendenz ist schwächer bei dem Szenario RCP2.6 und stärker bei RCP8.5.
Es ist auch ersichtlich, dass die Niederschlagsmenge auf der Alpensüdseite am grössten ist, insbesondere im Herbst und Frühling.

```{r percipitation}
Seasons(climate_projections_by_municipality, "pr", "2085", "RCP8.5")

## Regions and altitude
# spring
RegionsSeason(climate_projections_by_municipality, "pr", "RCP4.5", "MAM")
# summer
RegionsSeason(climate_projections_by_municipality, "pr", "RCP4.5", "JJA")
# autumn
RegionsSeason(climate_projections_by_municipality, "pr", "RCP4.5", "SON")
# winter
RegionsSeason(climate_projections_by_municipality, "pr", "RCP4.5", "DJF")

```


### Datenexport


```{r data export for frontend}

climate_projections_by_municipality %>%
  # iterate over bfs_ids to create one file for each municipality
  distinct(bfs_id) %>%
  pwalk(function(...) {
    current <- tibble(...)

    # filter and keep only entries with current municipality
    export_selection <- climate_projections_by_municipality %>%
      filter(bfs_id == current$bfs_id) %>%
      filter(
        rcp != "RCP4.5"
      ) %>%
      # remove columns that we don't need in frontend
      select(bfs_id, rcp, period, key, value, estimate, season) %>%
      # round values
      mutate(value = round(value, 1))

    write_json(
        export_selection,
        glue(
          "output/",
          "climate_projections_{current$bfs_id}.json"
        )
      )
    # browser()
  })

```

```{r export municipalities.json}
municipalities_in_urban_areas <-
  st_join(
  big_regions_shapefile %>% filter(Name_Prodr == "Grosse Agglomerationen"),
  municipality_geo %>% select(GMDNR, GMDNAME, geometry), 
  join = st_intersects
  )

plot <- ggplot() +
  geom_sf(
        data = municipalities_in_urban_areas,
        fill = "#56B1F7",
        color = "transparent"
      ) +
  geom_sf(
        data = municipality_geo,
        fill = "transparent",
        color = "#000000",
        size = 0.1
      ) +
  geom_text(
    data = municipality_geo,
    mapping = aes(
      x = E_CNTR,
      y = N_CNTR,
      label = GMDNR
    ),
    inherit.aes = FALSE,
    size = 0.5
  ) +
  theme_void() +
  theme(
    panel.grid.major = element_line("transparent"),
    legend.position = "none"
    )

ggsave("output/map.pdf", plot = plot)

municipalities_in_urban_areas_matrix <- as.matrix(
  municipalities_in_urban_areas %>% 
    st_drop_geometry %>% 
    select(GMDNR)
  )

write_json(
  climate_projections_by_municipality %>%
    distinct(bfs_id, .keep_all = TRUE) %>%
    select(
      bfs_id,
      name = GMDNAME,
      altitude,
      region
    ) %>%
    mutate(urban = bfs_id %in% municipalities_in_urban_areas_matrix) %>% 
    rename(bfsId = bfs_id),
  glue(
    "output/",
    "municipalities.json"
  )
)

```


## Linting

Der Code in diesem RMarkdown wird mit [lintr](https://github.com/jimhester/lintr) automatisch auf den Wickham'schen [tidyverse style guide](http://style.tidyverse.org/) überprüft.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
lintr::lint("main.Rmd", linters =
  lintr::with_defaults(
    object_length_linter = object_length_linter(45),
    commented_code_linter = NULL,
    trailing_whitespace_linter = NULL
  )
)

# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
```
